Number : float | int{};

// This is a subtype of Number, that is used for method argument types to resolve ambiguity
NumberA : Number{}

blah {}

// Another subtype of Number
NumberB : float | int {
    // The NumberB is the self type. You can use it like this or like the next example.
    ToString : (NumberB) -> string = NumberB.toString(42, 69 * 420 + NumberB)
    // This is the same as the above example, but it's a bit more explicit.
    ToStringTwo : (Self : NumberB) -> string = Self.toString
}


// A function type that takes two Numbers, but the numbers are basically type aliases for the Number type
// so that we can resolve ambiguity when calling the function.
Function: (NumberA, NumberB) -> Number {
    foo =  5 + 5
}

// This is a bit of syntactic sugar for the above function type.
// It's the same as the above function type, but it's a bit more concise.
// It creates two subtypes of Number, NumberA and NumberB, and then uses those subtypes in the function type.
// TODO: see if we can do return type inferences for inline function declarations
FunctionTwo : (A : Number, B : Number) -> Number {
    Test : Number = A + B
}

